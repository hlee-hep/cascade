#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cascade CLI — ROOT macro wrapper:
- inject YAML/kv params
"""
import argparse, sys, os, json, tempfile, shlex, subprocess, signal
from typing import Any, List, Dict, Tuple, Optional

# ------------ logging  ------------
def _log(level: str, msg: str) -> None:
    stream = sys.stderr if level in ("WARN", "ERROR") else sys.stdout
    print(f"[{level}] {msg}", file=stream)

# ------------ SIGINT handler ------------
def _install_sigint_handler() -> None:
    def handler(sig, frame):
        _log("WARN", "Interrupt requested (SIGINT). Exiting soon…")
    signal.signal(signal.SIGINT, handler)

# ------------ utils ------------
def _parse_kv(s: str) -> Tuple[str, Any]:
    if "=" not in s:
        raise argparse.ArgumentTypeError(f"--set expects k=v, got '{s}'")
    k, v = s.split("=", 1)
    v = v.strip()
    if v.lower() in ("true", "false"):
        return k, v.lower() == "true"
    try:
        return k, int(v)
    except ValueError:
        pass
    try:
        return k, float(v)
    except ValueError:
        pass
    try:
        return k, json.loads(v)
    except Exception:
        pass
    return k, v

# ------------ ROOT mode ------------
def _root_invoke(macro: str,
                 json_params_path: Optional[str],
                 extra_args: List[str],
                 root_exe: str = "root",
                 use_plus: bool = False) -> None:
    if not os.path.exists(macro):
        raise FileNotFoundError(f"macro not found: {macro}")
    macro_spec = f'{macro}{"+" if use_plus else ""}'
    arglist: List[str] = []
    if json_params_path is not None:
        arglist.append(json_params_path)
    arglist.extend(extra_args or [])
    quoted_with_dq = ",".join(f'"{str(a)}"' for a in arglist)
    cmd = [root_exe, "-l", "-q", f'{macro_spec}({quoted_with_dq})']
    _log("INFO", "[ROOT] " + " ".join(shlex.quote(c) for c in cmd))
    completed = subprocess.run(cmd)
    if completed.returncode != 0:
        _log("ERROR", f"ROOT macro exited with code {completed.returncode}")
        raise SystemExit(completed.returncode)

def cmd_macro_run(args) -> None:
    params: Dict[str, Any] = {}
    if args.yaml:
        params["_yaml_path"] = os.path.abspath(args.yaml)
    if args.set:
        params.update(dict(_parse_kv(s) for s in args.set))
    json_path: Optional[str] = None
    if params:
        fd, json_path = tempfile.mkstemp(prefix="cascade_params_", suffix=".json")
        os.close(fd)
        with open(json_path, "w", encoding="utf-8") as jf:
            json.dump(params, jf, ensure_ascii=False, indent=2)
        _log("DEBUG", f"Wrote temporary params JSON: {json_path}")
    try:
        _root_invoke(
            macro=args.macro,
            json_params_path=json_path,
            extra_args=args.extra or [],
            root_exe=args.root_exe,
            use_plus=not args.no_plus
        )
    finally:
        if json_path and os.path.exists(json_path):
            os.remove(json_path)
            _log("DEBUG", f"Removed temporary file: {json_path}")

# ------------ argparse ------------
def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="cascade", description="Cascade ROOT macro wrapper")
    p.add_argument("--macro", required=True, help="Path to ROOT macro (e.g., macros/My.C)")
    p.add_argument("--yaml", help="YAML config path (packed into JSON as _yaml_path)")
    p.add_argument("--set", action="append", help="k=v (repeatable)")
    p.add_argument("--extra", action="append", help="extra string args to macro", default=[])
    p.add_argument("--root-exe", default="root", help="ROOT executable name/path")
    p.add_argument("--no-plus", action="store_true", help="Do not append '+' to macro")
    p.set_defaults(func=cmd_macro_run)
    return p

def main(argv=None) -> None:
    _install_sigint_handler()
    argv = sys.argv[1:] if argv is None else argv
    parser = build_parser()
    args = parser.parse_args(argv)

    try:
        args.func(args)
    except KeyboardInterrupt:
        _log("WARN", "Interrupted")
        sys.exit(130)
    except SystemExit:
        raise
    except Exception as e:
        _log("ERROR", f"{e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
